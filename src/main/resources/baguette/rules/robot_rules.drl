package baguette

import baguette.*;
import robocode.*;
import robocode.ScannedRobotEvent;


// This definition has to be included everytime, to allow the robot consulting the actions
query "consult_actions"
  action: Action()
end


// 
////// RULES
//


// Used to store the victim's informations (if selected)
declare Victim
   name: String
   x: double
   y: double
   distance: double
   bearing: double
   heading: double
   velocity: double
   nextX: double
   nextY: double
   energy: double
end

declare Status
	energy: double
	others: int
	x: double
	y: double
	nextX: double
	nextY: double
	distanceRemaining: double
	gunHeading: double
	gunHeat: double
	gunTurnRemaining: double
	heading: double
	numRounds: int
	radarHeading: double
	radarTurnRemaining: double
	roundNum: int
	time: long
	turnRemaining: double
	velocity: double
end


// Convenience Rule: Eliminate actions with the same type if lower priority
// If that wasn't done, the robot would execute the last action inserted
rule "Clean actions with same type"
when
	$action1: Action($type: type, $priority1: priority)
	$action2: Action(type==$type, $priority2: priority)
	eval ($priority1 > $priority2)
then
    retract($action2);     // Removes action with worst priority
    System.out.println("Rule 1");
end


// when no internal status, create it
rule "Without status -> create one"
when 
	not (exists Status())
	$status: RobotState()
then
	Status status = new Status();
	status.setEnergy($status.getEnergy());
    status.setOthers($status.getOthers());
    status.setX($status.getX());
    status.setY($status.getY());
   	status.setDistanceRemaining($status.getDistanceRemaining());
	status.setGunHeading($status.getGunHeading());
	status.setGunHeat($status.getGunHeat());
	status.setGunTurnRemaining($status.getGunTurnRemaining());
	status.setHeading($status.getHeading());
	status.setNumRounds($status.getNumRounds());
	status.setRadarHeading($status.getRadarHeading());
	status.setRadarTurnRemaining($status.getRadarTurnRemaining());
	status.setRoundNum($status.getRoundNum());
	status.setTime($status.getTime());
	status.setTurnRemaining($status.getTurnRemaining());
	status.setVelocity($status.getVelocity());
    insert(status);
    System.out.println("Status updated"); 
end
    


// when internal status, update it
rule "With status -> update it"
when
	$prevStatus: Status()
	$newStatus: RobotState()
then
	$prevStatus.setEnergy($newStatus.getEnergy());
    $prevStatus.setOthers($newStatus.getOthers());
    $prevStatus.setX($newStatus.getX());
    $prevStatus.setY($newStatus.getY());
   	$prevStatus.setDistanceRemaining($newStatus.getDistanceRemaining());
	$prevStatus.setGunHeading($newStatus.getGunHeading());
	$prevStatus.setGunHeat($newStatus.getGunHeat());
	$prevStatus.setGunTurnRemaining($newStatus.getGunTurnRemaining());
	$prevStatus.setHeading($newStatus.getHeading());
	$prevStatus.setNumRounds($newStatus.getNumRounds());
	$prevStatus.setRadarHeading($newStatus.getRadarHeading());
	$prevStatus.setRadarTurnRemaining($newStatus.getRadarTurnRemaining());
	$prevStatus.setRoundNum($newStatus.getRoundNum());
	$prevStatus.setTime($newStatus.getTime());
	$prevStatus.setTurnRemaining($newStatus.getTurnRemaining());
	$prevStatus.setVelocity($newStatus.getVelocity());
    System.out.println("Status updated"); 
end		


// When there's no robot detected, force a complete turn of radar
rule "No detected robot -> radar complete turn"
when
	not (exists ScannedRobotEvent())
then
	insert (new Action(Action.RADAR_RIGHT, 360, 1));
	System.out.println("Rule 2");
end


// when stopped, and no victim detected, turns the radar and makes random movement
rule "stopped without victim -> random move and turn radar"
when
  RobotState(distanceRemaining == 0)
  not (exists Victim())
  $battle: BattleState()
then
  insert(new Action(Action.RADAR_RIGHT, 360, 1));
  insert(new Action(Action.TANK_RIGHT, (360*Math.random() - 180), 1));
  insert(new Action(Action.GUN_RIGHT, (360*Math.random() - 180), 1));
  double dist = Math.min($battle.getFieldWidth(), $battle.getFieldHeight())*Math.random();
  insert(new Action(Action.AHEAD, dist, 1));
  System.out.println("Rule 3");
end


// Detected victim : actualise its position and get close to it pointing gun and radar on it
rule "Detected victim -> follow it with gun and radar pointed"
   when
      $victimData : Victim ($victimName: name)
      $status : RobotState()
      $scannedVictim: ScannedRobotEvent(name == $victimName)
   then
      double absoluteAngle = Helper.absoluteAngle($status.getHeading(), $scannedVictim.getBearing());
      $victimData.setX(Helper.calculateX($status.getX(), absoluteAngle, $scannedVictim.getDistance()));                                            
      $victimData.setY(Helper.calculateY($status.getY(), absoluteAngle, $scannedVictim.getDistance()));
      $victimData.setDistance($scannedVictim.getDistance());
      
      insert(new Action(Action.TANK_RIGHT, $scannedVictim.getBearing(), 1));
      double gunRelativeAngle = Helper.relativeAngle($status.getHeading(), $status.getGunHeading());
      insert(new Action(Action.GUN_RIGHT, ($scannedVictim.getBearing() - gunRelativeAngle), 1));
      double radarRelativeAngle =  Helper.relativeAngle($status.getHeading(), $status.getRadarHeading());
      insert(new Action(Action.RADAR_RIGHT, ($scannedVictim.getBearing() - radarRelativeAngle), 1));
      insert(new Action(Action.AHEAD, ($scannedVictim.getDistance()-100), 1));
end



// Victim detected
// If relative gun angle equals the relative victim angle, with a 2 grad marge
// Shoot with max power
// (anterior rule will be overwritten)
rule "Victim in front of gun -> shoot"
   when
      $status : RobotState()
      Victim ($victimName: name)
      // Victim detected and pointed by gun (+- 2grad)
      ScannedRobotEvent(name == $victimName, $victimRelativeAngle: bearing)                       
      eval (Math.abs($victimRelativeAngle - Helper.relativeAngle($status.getHeading(), $status.getGunHeading())) <= 2)   
   then
      insert(new Action(Action.SHOOT, Math.min(Rules.MAX_BULLET_POWER, 0.10*$status.getEnergy()), 1));
      System.out.println("Victim "+$victimName+" pointed => SHOOT");
end



// When no victim is detected, and a robot is scanned, set him as victim and begin to follow
rule "Without victim -> set the first detected"
when
	not (exists Victim())
	$scannedVictim: ScannedRobotEvent()
	$status: RobotState()
then
    Victim victim = new Victim();
      double absoluteAngle = Helper.absoluteAngle($status.getHeading(), $scannedVictim.getBearing());
      victim.setName($scannedVictim.getName());
      victim.setX(Helper.calculateX($status.getX(), absoluteAngle, $scannedVictim.getDistance()));                                            
      victim.setY(Helper.calculateY($status.getY(), absoluteAngle, $scannedVictim.getDistance()));
      victim.setDistance($scannedVictim.getDistance());
      insert(victim);
      
      insert(new Action(Action.TANK_RIGHT, $scannedVictim.getBearing(), 1));
      double gunRelativeAngle = Helper.relativeAngle($status.getHeading(), $status.getGunHeading());
      insert(new Action(Action.GUN_RIGHT, ($scannedVictim.getBearing() - gunRelativeAngle), 1));
      double radarRelativeAngle =  Helper.relativeAngle($status.getHeading(), $status.getRadarHeading());
      insert(new Action(Action.RADAR_RIGHT, ($scannedVictim.getBearing() - radarRelativeAngle), 1));
      insert(new Action(Action.AHEAD, ($scannedVictim.getDistance()-100), 1));    
      System.out.println("Rule 6"); 
end


// Eliminate current Victim() Fact when killed
rule "Victim's death"
when
   $victim: Victim ($victimName: name)
   RobotDeathEvent( name == $victimName )
then 
   retract($victim);
   System.out.println("Tchau");
end


// When a wall is touched, reboot to the opposed angle
rule "Wall touched"
when
   HitWallEvent($relativeAngle: bearing)
then
   insert(new Action(Action.TANK_RIGHT, (- $relativeAngle), 5));
   insert(new Action(Action.AHEAD, 100, 5));
end


// When touching a victim, go back
rule "Victim touched"
when
   HitRobotEvent($name: name, $relativeAngle: bearing)
   Victim(name == $name)
then
   insert(new Action(Action.BACK, 100, 5));
end


// When touching an enemy robot, which isn't the victim, reboot in the opposed angle
rule "Not victim robot touched"
when
   HitRobotEvent($name: name, $relativeAngle: bearing)
   (or (not (exists Victim()))
       (Victim(name != $name)))
then
   insert(new Action(Action.TANK_RIGHT, (- $relativeAngle*1.50), 5));
   insert(new Action(Action.AHEAD, 100, 5));
end

